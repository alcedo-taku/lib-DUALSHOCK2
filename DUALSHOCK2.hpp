/**
 * @file DUALSHOCK2.hpp
 * @brief
 * @date Mar 6, 2022
 */
#ifndef DUALSHOCK2_HPP_
#define DUALSHOCK2_HPP_

#include "spi.h"
#include <array>

/**
 * 各コマンドを表わすenum class
 */
//enum class CMD:uint8_t{
//	CONFIG_MODE_ENTER,
//	CONFIG_MODE_EXIT,
//	SET_MODE_AND_LOCK,
//	VIBRATION_ENABLE,
//	QUERY_MODEL_AND_MODE,
//	READ_DATA,
//	CH_6,
//	CH_7
//};

/*struct type begin*/
//namespace CMD {
////	typedef float Element;
////	using Element = float; // C++だと上よりこちらのほうが一般的　テンプレートにも対応
//
//	constexpr uint8_t READ_DATA[]         = {0x01, 0x42, 0x00, 0x00, 0x00};
//	constexpr uint8_t READ_DATA_EX[]      = {0x01, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//	constexpr uint8_t READ_DATA_EXEX[]    = {0x01, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//	constexpr uint8_t CONFIG_MODE_ENTER[] = {0x01, 0x43, 0x00, 0x01, 0x00};
//	constexpr uint8_t CONFIG_MODE_EXIT[]  = {0x01, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//	constexpr uint8_t SET_MODE_AND_LOCK[] = {0x01, 0x44, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}; // アナログ、ロック
//	constexpr uint8_t PRESSURE_ENABLE[]   = {0x01, 0x4F, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00};
//	constexpr uint8_t PRES_TRANS_START[]  = {0x01, 0x43, 0x00, 0x00, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A};// CONFIG_MODE_EXIT を含む？
//};

namespace CMD {
	constexpr std::array<uint8_t,  5> READ_DATA 			= {0x01, 0x42, 0x00, 0x00, 0x00};
	constexpr std::array<uint8_t,  9> READ_DATA_EX	    	= {0x01, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	constexpr std::array<uint8_t, 21> READ_DATA_EXEX		= {0x01, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	constexpr std::array<uint8_t,  5> CONFIG_MODE_ENTER		= {0x01, 0x43, 0x00, 0x01, 0x00};
	constexpr std::array<uint8_t,  9> CONFIG_MODE_EXIT		= {0x01, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	constexpr std::array<uint8_t,  9> SET_MODE_AND_LOCK		= {0x01, 0x44, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}; // アナログ、ロック
	constexpr std::array<uint8_t,  9> PRESSURE_ENABLE		= {0x01, 0x4F, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00};
	constexpr std::array<uint8_t,  9> PRES_TRANS_START		= {0x01, 0x43, 0x00, 0x00, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A};// CONFIG_MODE_EXIT を含む？
	constexpr std::array<uint8_t,  9> QUERY_MODEL_AND_MODE	= {0x01, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	constexpr std::array<uint8_t,  9> QUERY_MODEL_AND_MODE2	= {0x01, 0x45, 0x00, 0x00, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A};
//	constexpr std::array<uint8_t,  9> ARDUINO_LIB_1			= {0xC0, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//	constexpr std::array<uint8_t,  5> ARDUINO_LIB_3			= {0x80, 0xC2, 0x00, 0x80, 0x00};
//	constexpr std::array<uint8_t,  9> ARDUINO_LIB_4			= {0x80, 0xA2, 0x00, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A};
//	constexpr std::array<uint8_t,  9> ARDUINO_LIB_5			= {0x80, 0x22, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00};
//	constexpr std::array<uint8_t,  9> ARDUINO_LIB_6			= {0x80, 0xC2, 0x00, 0x00, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A};
};


// Command bytes.
// When the lines contain values, the array is reused by modifying values on the fly.
//constexpr uint8_t cmd_init[]         = {0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
//constexpr uint8_t cmd_poll[]         = {0x01, 0x42, 0x00, 0x00, 0x00}; // READ_DATA
//constexpr uint8_t cmd_enter_cfg[]    = {0x01, 0x43, 0x00, 0x01}; // CONFIG_MODE_ENTER
//constexpr uint8_t cmd_exit_cfg[]     = {0x01, 0x43, 0x00, 0x00, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A}; // CONFIG_MODE_EXIT
//constexpr uint8_t cmd_enable_motor[] = {0x01, 0x4D, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; // VIBRATION_ENABLE
//constexpr uint8_t cmd_ad_mode[]      = {0x01, 0x44, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}; // SET_MODE_AND_LOCK

// Levels of the motors.
// This is necessary to store separately as the "state poll" command may over ride
// the motor strength with values of the other one of the two pads.
//constexpr uint8_t motor1Level[] = {0x00, 0x00};
//constexpr uint8_t motor2Level[] = {0x00, 0x00};

class DUALSHOCK2 {
private:
	SPI_HandleTypeDef* hspi;
//	std::unordered_map<CMD, std::array<uint8_t,9>> command;
	std::array<uint8_t, 21> receive_data;
public:
	DUALSHOCK2(SPI_HandleTypeDef& hspi);
	void init(uint32_t timeout);
	void update(uint32_t timeout);
	std::array<uint8_t,  9> get_data_ex();
	std::array<uint8_t, 21> get_data_exex();

	/**
	 *
	 * @tparam T
	 * @param command
	 * @param timeout
	 */
	template <class T> void send_command(T command, uint32_t timeout){
		HAL_GPIO_WritePin(SPI_SS_GPIO_Port, SPI_SS_Pin, GPIO_PIN_RESET);
		for (uint8_t i = 0; i < command.size(); i++) {
//			HAL_SPI_Transmit(hspi, (uint8_t*)&command[i], sizeof(command[i]), timeout);
			HAL_SPI_TransmitReceive(hspi,(uint8_t*)&command[i], (uint8_t*)&receive_data[i], sizeof(command[i]), timeout);
		}
		HAL_GPIO_WritePin(SPI_SS_GPIO_Port, SPI_SS_Pin, GPIO_PIN_SET);
		HAL_Delay(1);
	}
};

#endif /* DUALSHOCK2_HPP_ */
